| Word      | Description |
| ----------- | ----------- |
| Abstraction | A lambda abstraction is an anonymous function or lambda term. `(𝜆𝑥.𝑥 + 1)` The head of the expression, 𝜆𝑥., abstracts out the term 𝑥 + 1. We can apply it to any 𝑥 and recompute different results for each 𝑥 to which we apply the lambda. |
| Ad-hoc polymorphism | (sometimes called “constrained polymor- phism”) is polymorphism that applies one or more type class constraints to what would’ve otherwise been a parametrically polymorphic type variable. Here, rather than representing a uniformity of behavior across all concrete applications, the purpose of ad-hoc polymorphism is to allow the functions to have different behavior for each instance. This ad-hoc-ness is constrained by the types in the type class that defines the methods and Haskell’s requirement that type class instances be unique for a given type. |
| Anonymous Function | An anonymous function is a function that is not bound to an iden- tifier and is instead passed as an argument to another function and/or used to construct another function.  |
| Application | Application is how one evaluates or reduces lambdas, binding the parameter to the concrete argument. The argument is what specific term the lambda is applied to. Computations are per- formed in lambda calculus by applying lambdas to arguments until you run out of applications to perform: `(𝜆𝑥.𝑥)1` This example reduces to 1, as the identity 𝜆𝑥.𝑥 is applied to the value 1, 𝑥 is bound to 1, and since the lambda’s body is 𝑥, it just kicks the 1 out. In a sense, applying the 𝜆𝑥.𝑥 consumes it. We reduce the amount of structure with which we start. |
| Applicative | Applicative can be thought of as characterizing monoidal func- tors in Haskell. For a Haskeller’s purposes, it’s a way to functori- ally apply a function that is embedded in a structure f of the same type as the value you’re mapping it over: |
| Argument | The terms argument and parameter are often used interchange- ably. However, it is worthwhile to understand the distinction. A parameter, or formal parameter, represents a value that will be passed to a function when that function is called. Thus, param- eters are usually variables. An argument is an input value the function is applied to. A function’s parameter is bound to an argument when the function is applied to that argument. For example, in f x = x + 2, which takes an argument and returns that value added to 2, x is the one parameter of our function. We run the code by applying f to some argument. If the argument we pass to the parameter x is 2, our result would be 4. However, arguments can themselves be variables or be expressions that include variables, thus the distinction is not always clear. When we use “parameter” in this book, it will always refer to formal parameters, usually in a type signature, but we’ve taken the liberty of using “argument” somewhat more loosely. |
| Arity | Arity is the number of arguments a function accepts. This notion is a little slippery in Haskell since, due to currying, all functions are arity one (or “unary”), and we handle accepting multiple arguments by nesting functions. |
| Beta reduction | the process of replacing all occurrences of a parameter with a value or a function; for example `(λx.x + x)1` becomes `1` or `(λx.x)(λa.2a)` turns into `(λa.2a)`. |
| Bind | Bind is, unfortunately, a somewhat overloaded term. You first saw it used early in the book with respect to binding variables to values, such as with the following |
| Binding or bound  | Binding or bound is a common word used to indicate connection, linkage, or association between two objects. In Haskell, we use it to talk about what value a variable has, e.g., a parameter variable is bound to an argument value, meaning the value is passed into the parameter as input and each occurrence of that named parameter will have the same value. Bindings as a plurality will usually refer to a collection of variables and functions that can be referenced by name: |
| Binding | the assignment of an argument to a parameter |
| Bottom | Bottom is a non-value used to denote that the program cannot return a value or result. The most elemental manifestation of this is a program that loops infinitely. Other forms can involve things like writing a function that doesn’t handle all of its inputs and fails on a pattern match. |
| Catamorphism | A catamorphism is a generalization of folds to arbitrary datatypes. Where a fold allows you to break down a list into an arbitrary datatype, a catamorphism is a means of breaking down the structure of any datatype. The bool :: a -> a -> Bool -> a func- tion in Data.Bool is an example of a simple catamorphism for a simple, non-collection datatype. Similarly, maybe :: b -> (a -> b) -> Maybe a -> b is the catamorphism for Maybe. |
| Combinators |  lambda terms with no free variables |
| Composition | the application of a function to the result of hav- ing applied another function. The composition operator is a higher-order function, as it takes the functions it composes as arguments and then returns a function of the composition. |
| Concatenation | Concatenation is the joining together of sequences of values. Often in Haskell, this is meant with respect to the [], or list, datatype, which also applies to String (which, as we know, is [Char]). The concatenation function in Haskell is ++, which has type [a] -> [a] -> [a]. |
| Cons cell | A cons cell is a data constructor and a product of the types a and [a] as defined in the list datatype. Because it references the list type constructor itself in the second argument, it allows for the nesting of multiple cons cells, possibly indefinitely with the use of recursive functions, for representing an indefinite number of values in a series: |
| Cons | Cons is ordinarily used as a verb to signify that a list value has been created by cons’ing a value onto the head of another list value. In Haskell, : is the cons operator for the list type. It is a data constructor defined in the list datatype: |
| Currying | Currying is the process of transforming a function that takes multiple arguments into a series of functions that each take one argument and return one result. This is accomplished through nesting. In Haskell, all functions are curried by default. You don’t need to do anything special yourself. curry and uncurry already exist in Prelude: |
| Data declarations | Data declarations define new datatypes in Haskell. Data decla- rations always create a new type constructor but may or may not create new data constructors. Data declarations are how we refer to the entire definition that begins with the data keyword. |
| Data structures | Data constructors in Haskell provide a means of creating values that inhabit a given type. Data constructors in Haskell have a type and can either be constant values (nullary) or take one or more arguments, like functions. In the following example, Cat is a nullary data constructor for Pet, and Dog is a data constructor that takes an argument |
| Datatype |  A datatype is how we declare and create data for our functions to receive as inputs. Datatype declarations begin with the key- word data. A datatype is made up of a type constructor and zero or more data constructors, which each have zero or more arguments. |
| Derived instances | In Haskell, we have derived instances so that obvious or com- mon type classes, such as Eq, Enum, Ord, and Show can have their instances generated based solely on how a datatype is defined. Programmers can make use of these conveniences without writ- ing the code themselves, over and over. |
| Effects | Effects are how we refer to observable actions programs may take other than compute a value. If a function modifies some state or interacts with the outside world in a manner that can be observed, then we say it has an effect on the world. |
| Expression | An expression is a combination of symbols that conforms to syn- tactic rules and can be evaluated to some result. In Haskell, an expression is a well-structured combination of constants, vari- ables, and functions. While irreducible constants are technically expressions, we usually refer to those as “values,” so we usually mean “reducible expression” when we use the term expression. |
| Fold | A fold is a higher-order function which, given a function to accumulate the results and a recursive data structure, returns the built up value. Usually a “start value” for the accumulation is provided along with a function that can combine the type of values in the data structure with the accumulation. The term fold is typically used with reference to collections of values referenced by a recursive datatype. For a generalization of “breaking down structure,” see catamorphism |
| Function      | A mapping from the function's domain to its image (which is a subset of the co-domain). Every Haskell function is an expression that takes one argument. They always return a result. Functions are in prefix style by default. |
| Function parameter | A function parameter stands for a value, while an argument is an actual value that is being passed on to the function. Functions are in prefix style by default. |
| Function | a mathematical object that can be applied to an argument in order to return a result—and that’s it. We can also describe a function as a list of ordered pairs of its inputs and the resulting outputs, like a mapping. Given the function f x = x + 2 applied to the argument 2, we would have the ordered pair (2, 4) of its input and output. |
| Functor | Functor is a mapping between categories. In Haskell, this mani- fests as a type class that generalizes the concept of map: it takes a function (a -> b) and lifts it into a different type. This conven- tionally implies some notion of a function that can be applied to a value with more structure than the unlifted function was origi- nally designed for.  |
| Higher-kinded polymorphism | Higher-kinded polymorphism is polymorphism that has a type variable abstracting over types of a higher kind. Functor is an example of higher-kinded polymorphism, because the kind of the f parameter to Functor is * -> *. |
| higher-kinded type | A higher-kinded type type is any type whose kind has a function arrow in it and which can be described as a type constructor rather than as a type constant.  |
| Higher-order functions | functions which themselves take functions as arguments or return functions as results. Due to currying, technically any function that appears to take more than one argument is higher-order in Haskell. |
| Idempotence | When we say an operation or function is idempotent or satisfies idempotence, we mean that applying it multiple times doesn’t produce a different result from the first time. One example is multiplying by one or zero. You always get the same result as the first time you multiply any number by one or zero. |
| Infix notation | Functions in Haskell are usually called using prefix notation, or the function name followed by its arguments. However, some functions e.g. addition are called using infix notation - putting the function name between its two arguments |
| Infix notation | the style used in arithmetic and logic. Infix means that the operator is placed between the operands or arguments. An example would be the plus sign in an expression like 2 + 2. |
| Instance | An instance is the definition of how a type class should work for a given type. Instances are unique for a given combination of type class and type. |
| IO | IO is the type for values whose evaluation bears the possibility of causing side effects, such as printing text, reading text input from the user, reading or writing to files, or connecting to remote computers. This will be explained in much more depth in the chapter on IO. |
| Lambda calculus   | Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.        |
| Lambda | The lambda in lambda calculus is the greek letter 𝜆 used to introduce, or abstract, arguments for binding in an expression. |
| Lifting | Let’s talk about lifting. Because most of the rest of the book deals with applicatives and monads of various flavors, we’re going to be lifting a lot, but what do we mean? When Rudolf Carnap first described functors in the context of linguistics, he didn’t really talk about it as lifting anything, and mathematicians have fol- lowed in his footsteps, focusing on mapping and the production of outputs from certain types of inputs. Very mathematical of them, and yet Haskellers use the lifting metaphor often (as we do, in this book). |
| Local bindings | bindings local to particular expressions. The primary distinction here from top level bindings is that local bindings cannot be imported by other programs or modules. |
| Module | A module is the unit of organization that the Haskell program- ming language uses to collect together declarations of values, functions, datatypes, type classes, and type class instances. Any time you use import in Haskell, you are importing declarations from a module. |
| Monad | Monad is a type class reifying an abstraction that is commonly used in Haskell. Instead of an ordinary function of type a to b, you’re functorially applying a function that produces more structure itself and using join to reduce the nested structure that results: |
| Monadic function | A monadic function is one that generates more structure after having already been lifted over monadic structure.  |
| Monoid | A monoid is a set that is closed under an associative binary oper- ation and has an identity element. Closed is the posh mathemat- ical way of saying its type is: |
| Normal order | a common evaluation strategy in lambda cal- culi. Normal order means evaluating the leftmost, outermost lambdas first, evaluating nested terms after you’ve run out of arguments to apply. Normal order isn’t how Haskell code is evaluated. Haskell’s evaluation strategy is call-by-need, instead. |
| Operators | functions that are infix by default. In Haskell, operators must use symbols and not alphanumeric characters |
| parameter | The terms argument and parameter are often used interchange- ably. However, it is worthwhile to understand the distinction. A parameter, or formal parameter, represents a value that will be passed to a function when that function is called. Thus, param- eters are usually variables. An argument is an input value the function is applied to. A function’s parameter is bound to an argument when the function is applied to that argument. For example, in f x = x + 2, which takes an argument and returns that value added to 2, x is the one parameter of our function. We run the code by applying f to some argument. If the argument we pass to the parameter x is 2, our result would be 4. However, arguments can themselves be variables or be expressions that include variables, thus the distinction is not always clear. When we use “parameter” in this book, it will always refer to formal parameters, usually in a type signature, but we’ve taken the liberty of using “argument” somewhat more loosely. |
| Parametricity | Parametricity is the property that holds in the presence of para- metric polymorphism. Parametricity states that the behavior of a function will be uniform across all concrete applications of that function.  |
| Pattern matching | Pattern matching is a syntactic way of deconstructing product and sum types to get at their inhabitants. With respect to products, pattern matching gives you the means for destructuring and exposing the contents of products, binding one or more values contained therein to names. With sums, pattern matching lets you discriminate which inhabitant of a sum you mean to handle in that match. It’s best to explain pattern matching in terms of how datatypes work, so we’re going to use terminology that you may not fully understand yet. We’ll cover this more deeply soon. For example, the following is a “nullary” data constructor. It’s neither a sum or a product—it’s just a single value: |
| Point-free | is programming tacitly, or without mentioning arguments by name. This tends to look like “plumby” code where you’re routing data around implicitly or leaving off unnecessary arguments, thanks to currying. The “point” referred to in the term point-free is an argument. |
| Point-free | Point-free is programming tacitly, or without mentioning argu- ments by name. This tends to look like “plumby” code where you’re routing data around implicitly or leaving off unnecessary arguments, thanks to currying. The “point” referred to in the term point-free is an argument: |
| Pointfree | versions of functions drop arguments for the sake of readability and performance. For example, `print a = (putStrLn . show) a` becomes `print = putStrLn . show`. |
| Polymorphism | Polymorphism means being able to write code in terms of values that may be one of several types or of any type. Polymorphism in Haskell, specifically, is either parametric or constrained. |
| Product Type | In type theory, a product type is a type made of a set of types compounded over each other. In Haskell, we represent products using tuples or data constructors with more than one argument. The “compounding” is from each type argument to the data constructor representing a value that coexists with all the other values simultaneously. Products of types represent a conjunc- tion, “and,” of those types. If you have a product of Bool and Int, your terms will each contain a Bool and an Int value. |
| Property Testing | Property testing is a testing method where a subset of a large input space is validated, usually against a property or law some code should abide by.  |
| Recursion | Recursion is a means of computing results that may require an indefinite amount of work to obtain through the use of repeated function application. Most recursive functions that terminate or otherwise do useful work will often have a case that calls itself and a base case that acts as a backstop of sorts for the recursion. |
| Scope | A scope is where a variable can be validly referred to by name in a program. Something of global scope can be referred to anywhere in the entire program itself. A declaration at the top level of a Haskell module has module scope, and anything in that same module can refer to it. Another word used with the same meaning is visibility, because if a variable isn’t visible, then it’s not in scope and cannot be referenced by name. |
| Semigroup | A semigroup is a set that is closed under an associative binary operation—and nothing else. |
| Spine | The spine is a way to refer to the structure that glues a collection of values together. In the list datatype, it is formed by the recursive nesting of cons cells. The spine is, in essence, the structure of the collection that isn’t the values contained therein. Often, the term spine is used in reference to lists, but it applies in the case of data structures shaped like trees, as well.  |
| String | `String` is a type alias for `[Char]`, i.e. a list of characters. |
| Sum type | In type theory, a sum type of two types is a type whose terms are terms in either type, but not simultaneously. In Haskell, sum types are represented using the pipe, |, in a datatype definition. Sums of types represent a disjunction, “or,” of those types. If you have a sum of Bool and Int, your terms will be either a Bool value or an Int value. |
| Syntactic sugar |  syntax within a programming language de- signed to make expressions easier to read and write. |
| Tail call | A tail call is the final result of a function.  |
| Tail recursion | Tail recursion occurs in a function whose tail calls are recursive invocations of itself. This is distinguished from functions that call other functions in their tail call. |
| Top level bindings | Top level bindings in Haskell are bindings that stand outside of any other declaration. The main feature of top-level bindings is that they can be made available to other modules within your programs or to other people’s programs. |
| Type alias | a way to refer to a type constructor or type constant by an alternate name, usually to communicate something more specific or for brevity |
| Type class inheritance | Type class inheritance is when a type class has a superclass. This is a way of expressing that a type class requires another type class to be available for a given type before you can write an instance |
| Type class | A type class is a means of expressing faculties or interfaces that multiple datatypes may have in common. This enables us to write code exclusively in terms of those commonalities without repeating ourselves for each instance. Just as one may sum values of type Int, Integer, Float, Double, and Rational, we can avoid having different +, *, -, negate, etc. functions for each type by unifying them into a single type class. Importantly, these can then be used with all types that have a Num instance. Thus, a type class provides us a means to write code in terms of those operators and have our functions be compatible with all types that have instances of that type class, whether they already exist or are yet to be invented (by you, perhaps). |
| Type constructors | Type constructors in Haskell are not values and can only be used in type signatures. Just as data declarations generate data con- structors in order to create the values that inhabit a given type, data declarations also generate type constructors, which can be used to denote that type. In the above example, Pet is the type constructor. A guideline for differentiating the two kinds of constructors is that type constructors always go to the left of the = in a data declaration. |
| Type inference | Type inference is a faculty some programming languages, most notably Haskell and ML, have to infer principal types from terms without requiring explicit type annotations. There are, in some cases, terms in Haskell that can be well-typed but which have no principal type. In those cases, an explicit type annotation must be added. With respect to Haskell, the principal type is the most generic type that still type checks. More generally, a principal type is a property of the type system you’re interacting with. Principal typing holds for that type system if a type can be found for a term in an environment for which all other types for that term are instances of the principal type.  |
| Type variable | A type variable is a way to refer to an unspecified type or set of types in Haskell type signatures. Type variables ordinarily will be equal to themselves throughout a type signature. |
| Type | A type or datatype is a classification of values or data. Types in Haskell determine what values are members of the type or that inhabit the type. Unlike in other languages, datatypes in Haskell by default do not delimit the operations that can be performed on that data. |
| Unit testing | Unit testing is a method in which you test the smallest parts of an application possible. These units are individually and independently scrutinized for desired behaviors. Unit testing is better automated, but it can also be done manually via a human entering inputs and verifying outputs. |
| Value | A value is an expression that can not be evaluated any further. Haskell uses lazy evaluation, i.e. it only evaluates an expression when it is forced to by other terms which refer to the expression. |